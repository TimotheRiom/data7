% Autogenerated translation of Readme.md by Texpad
% To stop this file being overwritten during the typeset process, please move or remove this header

\documentclass[12pt]{book}
\usepackage{graphicx}
\usepackage{fontspec}
\usepackage[utf8]{inputenc}
\usepackage[a4paper,left=.5in,right=.5in,top=.3in,bottom=0.3in]{geometry}
\setlength\parindent{0pt}
\setlength{\parskip}{\baselineskip}
\setmainfont{Helvetica Neue}
\usepackage{hyperref}
\pagestyle{plain}
\begin{document}

\chapter*{Data7 Project: An automatically generated Vulnerability dataset}

\href{https://opensource.org/licenses/Apache-2.0}{\includegraphics{https://img.shields.io/badge/License-Apache%202.0-blue.svg}}

\section*{What is it?}

Data7 is a tool that put together vulnerability report and vulnerability patches  of a given software project in an automated way under the form of a dataset. Once created the dataset can then easily be updated with the latest information available. The information that can be found in the dataset is the following:

\begin{itemize}
\item CVE number
\item description
\item CWE number (if applicable)
\item time of creation 
\item time of last modification
\item CVSS severity score
\item bug ids (if existing)  \\
\item list of impacted versions
\item list of commits that fixed the vulnerability which contains:

\begin{itemize}
\item hash
\item timestamp
\item message
\item fixes (files in their states before and after fix)
\end{itemize}
\end{itemize}

\section*{Why?}

When investigating a vulnerability, a security analyst need as much information as possible on it and usually reports are a good starting point. However, the most insightful piece of information on the vulnerability is usually the fix that was created to solve it. From the fix, the origin of the vulnerability and its type can be determined. Fixes when available can be found as separated links in the reports but it is far from being always the case. 
If linking fixes and reports by hand is possible, it is time consuming. So when the analysis of not one but many vulnerabilities is considered then it is not possible to do it by hand anymore. A good example of a case where the analysis of a large number of vulnerabilities is required is the creation of a Vulnerability Prediction Model. 

Thus, the link should be made automatically and not manually which is possible by cross-checking information from vulnerability report, bug trackers and versioning history and that's precisely what data7 is doing.

\section*{Requirements}

To create and update a dataset an internet connection is required. However nothing is required to read an existing data7.
Other dependencies are handled through maven.

\section*{How does it work ?}

For a given project P

\begin{itemize}
\item Creating a dataset

\begin{enumerate}
\item Data7 will first connect to the NVD database and download all the XML feeds for vulnerabilities (2002-Current Year)
\item Data7 will then parse all the XML and retrieve all vulnerabilities reported for P over the history
\item For each vulnerability, all declared links are analysed and if a mention to a bug report is made or a link to a fix commit is present, they are saved
\item The git repository of P is cloned in a local folder
\item For each vulnerability that had a link to a fixing commit, all information on the commit are retrieved from the git repository and added to the one of the vulnerability
\item For each commit in the versioning history that was not yet analysed in (v.), analyse the message and look for a bug id that was present in the report or for a CVE Identifier and if a match is made then commit information is added to the vulnerability information.
\end{enumerate}
\item Updating a dataset

\begin{enumerate}
\item Data7 first check when the latest update occurred, if less than 7 days passed since the last update, only the modified and recent xml feed are downloaded, otherwise all xml feeds from years that have been modified since the last update are downloaded
\item Data7 will then parse the XML and retrieve all vulnerabilities reported for P and create a new entry if there is a new vulnerability or update it if necessary
\item For each updated or created vulnerability entry, look for a new link of commit fix and/or bug id.
\item The git repository is pulled
\item For all new/updated entry  that has a new link, retrieve the commit information
\item For all entry that has a new bug id, check whether this bug id was already found in the commit history (from a previous crawl)
\item For all latest commit (since latest update), analyse the message and look for a bug id that was present in the report or for a CVE Identifier and if a match is made then the commit information is added to the vulnerability information. 
\end{enumerate}
\end{itemize}

\section*{Dataset Structure}

The dataset generated by data7 can be accessed in two ways (a third one is planned in the future) either through an API relying on a data7 Object that can be serialized or through an XML file.

\subsection*{API (binary form)}

\includegraphics{doc/model.png}

When calling upon the creation or the update of a dataset, the user will receive a Data7 object. This object contains information on the project the dataset is based on (see next section), and the vulnerability dataset (VulnerabilitySet Object), other fields are present but only contain additive information required by the tool for update such as a list of bug id and their corresponding hash commit, a list of bug id to CVE identifiers, a list of all hash already processed and a list of found cve identifiers in commit for whose report is not yet available which can be interesting to investigate not yet disclosed vulnerabilities.

The vulnerabilitySet object is composed of the following information, a list of every vulnerability ever reported for the chosen project (list of Vulnerability Object) and the last time the dataset was updated last.

A Vulnerability Object entry has the following information integrated:

\begin{itemize}
\item CVE number
\item description of the vulnerability in the report
\item CWE number (if applicable)
\item time of creation 
\item time of last modification
\item CVSS severity score
\item bug ids (if existing, can be more than one)  \\
\item list of impacted versions
\item list of fixing commit (Commit object)
\end{itemize}

A Commit Object contains the hash, the message and the timestamp of the commit as well as the list of files that were modifier (FileFix Object).

A FileFix Object contains information on time the file was last modified before the given commit and its corresponding previous hash as well as the file in its state before and after commit (FileInterest Object).

A FileInterest Object contains the text of the file and its fullPath in the project.

\subsection*{XML exporter}

The dataset can as well be exported as an XML file that will only contain vulnerability with reported fixes.
The schema of the xml is the following:

\texttt{xml
$<$?xml version="1.0" encoding="UTF-8" standalone="no"?$>$
    $<$data7 last\_updated="YYYY-MM-DD HH:mm:ss CEST" project="project name"$>$
      $<$cve id="CVE-YYYY-XXXXXX" last\_modified="timestamp"$>$
        $<$cwe$>$$<$/cwe$>$
        $<$score$>$$<$/score$>$
        $<$description$>$$<$/description$>$
        $<$affectedVersions$>$
          $<$version$>$$<$/version$>$
        $<$/affectedVersions$>$
        $<$bugs/$>$
        $<$patches$>$
          $<$commit hash="aaaaaaa" timestamp="xxxxxxx"$>$
            $<$message$>$$<$/message$>$
            $<$files$>$
              $<$file$>$
                $<$before hash="aaaaaaaa" path="src/file.c"$>$
                Content of the file
                $<$/before$>$
                $<$after path="src/file.c"$>$
                Content of the file
                $<$/after$>$
              $<$/file$>$
            $<$/files$>$
          $<$/commit$>$
        $<$/patches$>$
      $<$/cve$>$
    $<$/data7$>$
}                

\subsection*{Extending to other tools/database}

As analysts might want to import the dataset to their own tool or favourite database, a last option is possible that allow the user to import the data at the same time the dataset is being built/update through an Observer. Indeed, when asking to update/create a dataset the user can pass as an argument a listener that implements the DatasetUpdateListener interface that will notify of the latest update in live.

The interface offer 6 notifications:

\begin{itemize}
\item when a bug is added to a vulnerability
\item when a commit is added to a vulnerability
\item when a score is updated (CVSS)
\item when a cwe is updated
\item when a new vulnerability is added
\item when the update is finished
\end{itemize}

and is presented as follows:

```java
package data7.importer.cve;

import data7.model.vulnerability.Vulnerability;

import java.util.EventListener;

public interface DatasetUpdateListener extends EventListener \{

\begin{verbatim}
void bugAddedTo(Vulnerability vulnerability, String bugId);

void commitAddedTo(Vulnerability vulnerability, String hash);

void scoreUpdatedFor(Vulnerability vulnerability);

void cweUpdatedFor(Vulnerability vulnerability);

void addVulnerability(Vulnerability vulnerability);

void updatefinished();
\end{verbatim}

\}
``` 

This interface allows to develop more functionality for the dataset such as the one currently in development in the graph section, which uses a temporal graph database to store the dataset. Note that it might be better to first do a batch import and then use the interface when update is being done.

\section*{Supported projects}

Currently four open source projects are supported :

\begin{itemize}
\item Linux Kernel
\item Wireshark
\item OpenSSL
\item SystemD
\end{itemize}

but it can easily be extended to any other project where it is possible to find the following information:

\begin{itemize}
\item name of the project as it appears in NVD database, e.g, linux\_kernel
\item url of a git remote repository, e.g, https://github.com/torvalds/linux
\item regular expression catching link to remote repository and hashes in it, e.g, .\emph{?(github\textbackslash{}.com$\vert$git\textbackslash{}.kernel\textbackslash{}.org).}?(commit)+.*?(h\textbackslash{}=$\vert$/)+([a-f0-9]+)
\item url of a bug tracker, e.g, https://bugzilla.kernel.org/
\item regular expression catching link to bug tracker and bug id in it, e.g, .\emph{(bugzilla\textbackslash{}.kernel\textbackslash{}.org).}?(id\textbackslash{}=)([0-9]+)
\item regular expression catching bug id in git commit message, e.g, .\emph{(bugzilla\textbackslash{}.kernel\textbackslash{}.org).}?(id\textbackslash{}=)([0-9]+)
\end{itemize}

\section*{How to use the tools}

\begin{enumerate}
\item To use the tool, the first step is to create a folder in your local storage that will gather all data.
The structure once run the tool should look like this

\begin{itemize}
\item myfolder

\begin{itemize}
\item git
\item cve
\item xml
\item binary
\end{itemize}
\end{itemize}
\item Then head to data7/src/main/java/data7/Ressources.java and change the PATH\emph{TO}SAVE value by your folder path.
\item Once done, you can run mvn install and the tool is installed
\item To call it from your code, just call 
```java
import data7.project.CProjects;
import data7.project.Project;   
\end{enumerate}

Importer.updateOrCreateDatasetFor(aProject);
// Projects are available in projects module
//like CProjects.LINUX\_KERNEL
``` 

Note that on creation of the dataset it might be better for the largest project (Linux, Wireshark)to first clone the git repository using command line in your folder under the subfolder git (in the case of Linux, don't forget to rename Linux into linux\_kernel)

\section*{Statistics}

As of 5th June 2018

$\vert$ Projects   $\vert$ Time to create $\vert$ Dataset size $\vert$Number of vulnerabilities $\vert$ NoV with Fixes $\vert$ average CVSS $\vert$ avg CVSS with fixes $\vert$ Number of Fix $\vert$ Number of FileFix$\vert$ Number of Unique Vulnerable Files $\vert$
$\vert$:----------:$\vert$:--------------:$\vert$:------------:$\vert$:------------------------:$\vert$:--------------:$\vert$:------------:$\vert$:-------------------:$\vert$:-------------:$\vert$:----------------:$\vert$:---------------------------------:$\vert$
$\vert$Linux Kernel$\vert$115 mn          $\vert$279.7 MB      $\vert$2082                      $\vert$1202            $\vert$5.41          $\vert$5.34                 $\vert$1332           $\vert$ 2612             $\vert$1508                               $\vert$
$\vert$Wireshark   $\vert$129 mn          $\vert$561.9 MB      $\vert$ 531                      $\vert$ 265            $\vert$4.99          $\vert$5.01                 $\vert$ 850           $\vert$  987             $\vert$ 221                               $\vert$
$\vert$OpenSSL     $\vert$  8 mn          $\vert$173.3 MB      $\vert$ 187                      $\vert$ 126            $\vert$5.34          $\vert$5.42                 $\vert$ 493           $\vert$ 1018             $\vert$ 164                               $\vert$
$\vert$SystemD     $\vert$  2 mn          $\vert$  2.4 MB      $\vert$   9                      $\vert$   5            $\vert$5.76          $\vert$5.60                 $\vert$   5           $\vert$    6             $\vert$   5                               $\vert$
$\vert$Total       $\vert$254 mn          $\vert$  1.0 GB      $\vert$2809                      $\vert$1598            $\vert$5.375         $\vert$5.34                 $\vert$2680           $\vert$ 4623             $\vert$1898                               $\vert$

\subsection*{Top 10 CWE}

$\vert$ Rank $\vert$ Linux    $\vert$ Wireshark $\vert$ OpenSSL $\vert$ SystemD $\vert$
$\vert$:----:$\vert$:--------:$\vert$:---------:$\vert$:-------:$\vert$:-------:$\vert$
$\vert$ 1    $\vert$ 264 (318)$\vert$  20 (136) $\vert$ 310 (32)$\vert$ 20 (3)  $\vert$
$\vert$ 2    $\vert$ 200 (219)$\vert$ 399 (108) $\vert$ 399 (28)$\vert$ 264 (2) $\vert$
$\vert$ 3    $\vert$ 399 (212)$\vert$ 119  (98) $\vert$ 116 (17)$\vert$ 362 (2) $\vert$
$\vert$ 4    $\vert$ 119 (204)$\vert$ 189  (51) $\vert$ 200 (15)$\vert$ 787 (1) $\vert$
$\vert$ 5    $\vert$  20 (161)$\vert$ 400  (14) $\vert$  20 (12)$\vert$ 119 (1) $\vert$
$\vert$ 6    $\vert$ 189 (106)$\vert$  74   (9) $\vert$ 189 (11)$\vert$         $\vert$
$\vert$ 7    $\vert$ 362  (89)$\vert$ 476   (8) $\vert$ 362  (5)$\vert$         $\vert$
$\vert$ 8    $\vert$ 476  (45)$\vert$ 134   (5) $\vert$         $\vert$         $\vert$
$\vert$ 9    $\vert$ 284  (45)$\vert$ 200   (4) $\vert$   -     $\vert$         $\vert$
$\vert$ 10   $\vert$ 416  (28)$\vert$ -         $\vert$   -     $\vert$         $\vert$

\subsection*{Top 10 CWE with Fixes}

$\vert$ Rank $\vert$ Linux    $\vert$ Wireshark $\vert$ OpenSSL $\vert$ SystemD $\vert$
$\vert$:----:$\vert$:--------:$\vert$:---------:$\vert$:-------:$\vert$:-------:$\vert$
$\vert$ 1    $\vert$ 119 (163)$\vert$  20 (81)  $\vert$ 310 (20)$\vert$ 264 (1)$\vert$
$\vert$ 2    $\vert$ 399 (146)$\vert$ 399 (62)  $\vert$ 399 (20)$\vert$ 787 (1)$\vert$
$\vert$ 3    $\vert$ 200 (137)$\vert$ 119 (52)  $\vert$ 200 (15)$\vert$ 119 (1)$\vert$
$\vert$ 4    $\vert$ 264 (135)$\vert$ 400 (14)  $\vert$ 119 (12)$\vert$ 20 (1) $\vert$
$\vert$ 5    $\vert$  20 (134)$\vert$ 189 (10)  $\vert$  20 (12)$\vert$ 362 (1)$\vert$
$\vert$ 6    $\vert$ 189  (88)$\vert$  74  (9)  $\vert$ 189  (6)$\vert$        $\vert$
$\vert$ 7    $\vert$ 362  (72)$\vert$ 476  (8)  $\vert$ 362  (4)$\vert$        $\vert$
$\vert$ 8    $\vert$ 476  (35)$\vert$ 19   (3)  $\vert$ -       $\vert$        $\vert$
$\vert$ 9    $\vert$ 416  (25)$\vert$ 754  (3)  $\vert$ -       $\vert$        $\vert$
$\vert$ 10   $\vert$ 125  (20)$\vert$ -         $\vert$ -       $\vert$        $\vert$

\subsection*{Top 10 CWE ratio}

$\vert$ Rank $\vert$ Linux    $\vert$ Wireshark $\vert$ OpenSSL  $\vert$ SystemD  $\vert$
$\vert$:----:$\vert$:--------:$\vert$:---------:$\vert$:--------:$\vert$:--------:$\vert$
$\vert$ 1    $\vert$  17 (100)$\vert$ 400 (100) $\vert$ 200 (100)$\vert$ 787 (100)$\vert$
$\vert$ 2    $\vert$ 415 (100)$\vert$  74 (100) $\vert$  20 (100)$\vert$ 119 (100)$\vert$
$\vert$ 3    $\vert$ 310  (92)$\vert$ 476 (100) $\vert$ 362 (80) $\vert$ 264  (50)$\vert$
$\vert$ 4    $\vert$  19  (91)$\vert$  19 (100) $\vert$ 399 (71) $\vert$ 362  (50)$\vert$
$\vert$ 5    $\vert$ 416  (89)$\vert$ 754 (100) $\vert$ 119 (70) $\vert$  20  (33)$\vert$
$\vert$ 6    $\vert$ 125  (86)$\vert$  20  (60) $\vert$ 310 (62) $\vert$          $\vert$
$\vert$ 7    $\vert$  20  (83)$\vert$ 399  (57) $\vert$ 189 (54) $\vert$          $\vert$
$\vert$ 8    $\vert$ 189  (83)$\vert$ 119  (53) $\vert$ -        $\vert$          $\vert$
$\vert$ 9    $\vert$ 362  (81)$\vert$ 189  (20) $\vert$ -        $\vert$          $\vert$
$\vert$ 10   $\vert$ 119  (80)$\vert$ -         $\vert$ -        $\vert$          $\vert$

\subsection*{Top 10 Vulnerable Files}

$\vert$ Rank $\vert$ Linux                     $\vert$ Wireshark                              $\vert$ OpenSSL                    $\vert$ SystemD                                $\vert$
$\vert$:----:$\vert$:--------------------------$\vert$:---------------------------------------$\vert$:---------------------------$\vert$:---------------------------------------$\vert$
$\vert$ 1    $\vert$ arch/x86/kvm/x86.c (17)   $\vert$ epan/proto.c (24)                      $\vert$ ssl/s3\emph{clnt.c (53)         $\vert$ src/resolve/resolved-dns-packet.c (2)  $\vert$
$\vert$ 2    $\vert$ fs/namei.c (14)           $\vert$ epan/dissectors/packet-nbap.c (19)     $\vert$ ssl/s3}srvr.c (41)         $\vert$ src/resolve/resolved-dns-packet.h (1)  $\vert$
$\vert$ 3    $\vert$ net/socket.c (14)         $\vert$ epan/dissectors/packet-ncp2222.inc (19)$\vert$ ssl/d1\emph{both.c (35)         $\vert$ src/util.c (1)                         $\vert$
$\vert$ 4    $\vert$ kernel/signal.c (14)      $\vert$ epan/dissectors/packet-wccp.c (18)     $\vert$ ssl/t1}lib.c (34)          $\vert$ src/nss-mymachines/nss-mymachines.c (1)$\vert$
$\vert$ 5    $\vert$ fs/namespace.c (14)       $\vert$ epan/crypt/airpdcap.c (18)             $\vert$ ssl/d1\emph{pkt.c (22)          $\vert$ src/tmpfiles/tmpfiles.c (1)            $\vert$
$\vert$ 6    $\vert$ kernel/bpf/verifier.c (13)$\vert$ epan/dissectors/packet-ber.c (17)      $\vert$ crypto/asn1/tasn}dec.c (20)$\vert$                                        $\vert$
$\vert$ 7    $\vert$ net/sctp/socket.c (13)    $\vert$ epan/dissectors/packet-umts\emph{fp.c (16)  $\vert$ ssl/ssl.h (20)             $\vert$                                        $\vert$
$\vert$ 8    $\vert$ fs/exec.c (13)            $\vert$ epan/dissectors/packet-wbxml.c (15)    $\vert$ ssl/s3}pkt.c (20)          $\vert$                                        $\vert$
$\vert$ 9    $\vert$ arch/x86/kvm/vmx.c (13)   $\vert$ epan/dissectors/packet-wsp.c (14)      $\vert$ ssl/ssl\emph{err.c (17)         $\vert$                                        $\vert$
$\vert$ 10   $\vert$ fs/open.c (12)            $\vert$ epan/dissectors/packet-wcp.c (13)      $\vert$ crypto/x509/x509}vfy.c (16)$\vert$                                        $\vert$

\section*{Additional Libraries Included}

In this tool, three custom-made libraries are included:

\subsection*{Git Utils}

This library coded in Kotlin provide some useful function when trying to mine a git repository.
The following methods are available

\begin{itemize}
\item retrievingFileFromSpecificCommit
\item listOfCommitImpactingAFile
\item previousCommitImpactingAFile
\item gitBlame
\item gitBlameNbDev
\item getDevHistoryOfAFile (use Developer History class)
\item getDeltaFile (Delta History)
\item getListOfModifiedFile
\item getCommitMessage
\item getTimeCommit
\end{itemize}

this library work on local repository but also offer the possibility to clone a remote repository: 

\texttt{kotlin
   // for already existing git repo  
     val git = GitUtilitary("pathto .git folder")
   // to clone the repo
     val git = GitUtilitary("remote repo adress","path to folder")
}

\subsection*{Misc}

This library coded as well in Kotlin contains additional useful function such as downloading a file, unzipping a file, normalizing a path and getting the recursive list of directories.

\subsection*{CWE Importer}

For those wishing to analyse cwe as well a last library is made available. The library can simply be called using:
\texttt{java
Importer.getListOfCWE();
}
This call will download on the nvd website the xml with all the description of CWE and parse it before serializing for good. This is especially useful for studies that focus on CWE when using the data7. In addition a fiel childOf is present for each CWE which allows to rebuild the hierarchy of CWE type.

\section*{About Me}

This tool was developed during my thesis and is made available to everyone. :)

\end{document}
